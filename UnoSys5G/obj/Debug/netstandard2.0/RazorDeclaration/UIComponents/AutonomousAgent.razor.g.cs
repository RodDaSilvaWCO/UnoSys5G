// <auto-generated/>
#pragma warning disable 1591
#pragma warning disable 0414
#pragma warning disable 0649
#pragma warning disable 0169

namespace UnoSys5G.UIComponents
{
    #line hidden
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Components;
#line 1 "C:\UnoSys5GGitHub\UnoSys5G\_Imports.razor"
using Microsoft.MobileBlazorBindings;

#line default
#line hidden
#line 2 "C:\UnoSys5GGitHub\UnoSys5G\_Imports.razor"
using Microsoft.MobileBlazorBindings.Elements;

#line default
#line hidden
#line 3 "C:\UnoSys5GGitHub\UnoSys5G\_Imports.razor"
using Xamarin.Essentials;

#line default
#line hidden
#line 4 "C:\UnoSys5GGitHub\UnoSys5G\_Imports.razor"
using Xamarin.Forms;

#line default
#line hidden
#line 5 "C:\UnoSys5GGitHub\UnoSys5G\_Imports.razor"
using UnoSys5G.Core;

#line default
#line hidden
#line 1 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\_Imports.razor"
using System.Net.Http;

#line default
#line hidden
#line 2 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\_Imports.razor"
using System.Net.Http.Json;

#line default
#line hidden
#line 3 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\_Imports.razor"
using Microsoft.AspNetCore.Components.Forms;

#line default
#line hidden
#line 4 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\_Imports.razor"
using Microsoft.AspNetCore.Components.Routing;

#line default
#line hidden
#line 5 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\_Imports.razor"
using Microsoft.AspNetCore.Components.Web;

#line default
#line hidden
#line 6 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\_Imports.razor"
using Microsoft.JSInterop;

#line default
#line hidden
#line 7 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\_Imports.razor"
using UnoSys5G.WebUI.Shared;

#line default
#line hidden
#line 8 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\_Imports.razor"
using UnoSys5G.Core.Interfaces;

#line default
#line hidden
#line 1 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\AutonomousAgent.razor"
using UnoSys5G.Services;

#line default
#line hidden
#line 2 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\AutonomousAgent.razor"
using System;

#line default
#line hidden
#line 3 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\AutonomousAgent.razor"
using System.IO;

#line default
#line hidden
    public partial class AutonomousAgent : Microsoft.AspNetCore.Components.ComponentBase, IDisposable
    {
        #pragma warning disable 1998
        protected override void BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder __builder)
        {
        }
        #pragma warning restore 1998
#line 88 "C:\UnoSys5GGitHub\UnoSys5G\UIComponents\AutonomousAgent.razor"
 

    const float leftMargin = 10;
    private DateTime starttime = DateTime.Now;

    public void Dispose()
    {
        networkOverlay.TimerTick -= TimerService_TimerTick;
    }

    private bool CollissionDetection(vD2DNodeState playerToDisplayState)
    {
        bool collidesWithAnotherPlayer = false;
        try
        {
            foreach (var alreadyDisplayedPlayerState in displayedPlayers)
            {
                //System.Diagnostics.Debug.Print($"Testing [{playerToDisplayState.PlayerID}->({playerToDisplayState.PlayerPosX},{playerToDisplayState.PlayerPosY})");
                //System.Diagnostics.Debug.Print($"    --> [{alreadyDisplayedPlayerState.PlayerID}->({alreadyDisplayedPlayerState.PlayerPosX},{alreadyDisplayedPlayerState.PlayerPosY})");
                if (alreadyDisplayedPlayerState.PlayerPosX == playerToDisplayState.PlayerPosX && alreadyDisplayedPlayerState.PlayerPosY == playerToDisplayState.PlayerPosY)
                {
                    if (networkOverlay.IsThisNode(playerToDisplayState.ID))  // Increment collision counter if "this" node did the colliding
                    {
                        App.CollisionCount += 1;
                        collidesWithAnotherPlayer = true;
                    }
                    break;
                }
            }
            if (!collidesWithAnotherPlayer)
            {
                displayedPlayers.Add(playerToDisplayState);
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.Print($"Indexer.CollssionDetection() - ERROR: ({playerToDisplayState.PlayerPosX},{playerToDisplayState.PlayerPosY}) {ex.Message}");
        }
        return collidesWithAnotherPlayer;
    }

    private List<vD2DNodeState> displayedPlayers = null;


    protected override async Task OnInitializedAsync()
    {
        await networkOverlay.Connect();
        App.NetworkOverlay = networkOverlay;
        //meshSyncDemo.IsAutoMode = App.InitialAutonomousMode;
        networkOverlay.TimerTick += TimerService_TimerTick;
        p2pDemo.BufferReady += SyncSimulcastStartTime;
        base.OnInitialized();
    }


    private int frameDisplayed = 0;
    protected string Image64 { get; set; }
    private bool playbackstarted = false;

    private async void TimerService_TimerTick()
    {
        App.UnoSysClockTimeUtc = timeManager.ProcessorUtcTime;
        if ((DateTime.Now - starttime).TotalSeconds > App.StartDelay)
        {
            if (App.DemoID == 0)
            {
                //if (meshSyncDemo.IsAutoMode)
                if (App.IsAutonomousMode)
                {
                    meshSyncDemo?.SetRandomPoint();
                    meshSyncDemo?.BroadCastMeshNodeStateChange(
                        new vD2DNodeState(networkOverlay.NodeID, meshSyncDemo.CurrentXPos, meshSyncDemo.CurrentYPos, meshSyncDemo.Radius, App.CurrentSpeed, meshSyncDemo.CurrentDirection));
                }
                await this.InvokeAsync(StateHasChanged);
            }
            else
            {
                if (App.Play && !playbackstarted)
                {
                    playbackstarted = true;
                    //p2pDemo.QueueSimulcast(0, (App.DemoID == 2 ? Int32.Parse(App.ClientID) : -1));
                    p2pDemo.QueueSimulcast(0, (App.DemoID == 2 ? Convert.ToInt32(meshNodeInfo.MeshNodeID) : -1));
                }
            }
        }
    }


    private async void SyncSimulcastStartTime(object sender, BufferReadyEventArgs e)
    {
        // The purpose of this routine is to synchronize all of the nodes in the Mesh to start playing the video at the same time.
        // Each node will have this event handler called once it has buffered enough (approx 30) frames.
        // The problem is that each node might get here at slightly different times (as much as a couple of seconds apart).
        // In order to ensure all videos start playing at the exact same time we need to delay until an agreed up time in the future on the
        // already synchronized UnoSys System Clock.  In this way early nodes will "wait" for late nodes, so that all can start together.
        long futureStartTimeInTicks = e.InitalPlayEventTimeInTicks + (TimeSpan.TicksPerSecond * 2);  // start time 3 seconds into future from initial Play event
                                                                                                     // Spin until its time to start
        while (futureStartTimeInTicks > timeManager.ProcessorUtcTimeInTicks)
        {
            // Spin....it's only for a short time
            //System.Diagnostics.Debug.Print($"Spinning...{(futureStartTimeInTicks > timeManager.ProcessorUtcTimeInTicks)} futureStartTimeInTicks={futureStartTimeInTicks}, now={timeManager.ProcessorUtcTimeInTicks}");
            await Task.Yield();
        }
        // Start playing.... NOTE:  Next two lines ensure we don't reentery from TimerService_TimerTick about
        App.Play = true;
        playbackstarted = true;
        await VideoPlayBack(27);
    }

    private async Task VideoPlayBack(int playbackSpeedInFPS)
    {
        while (App.Play)
        {
            await Task.Delay(1000 / playbackSpeedInFPS);
            if (frameDisplayed < 2228)
            {
                IFrameInfo frameInfo = p2pDemo.FetchNextBufferedFrameInfo();
                if (frameInfo != null && frameInfo.FrameBytes != null)
                {
                    Image64 = "data:image/png;base64, " + Convert.ToBase64String(frameInfo.FrameBytes);
                    frameDisplayed++;
                    frameInfo = null;
                    await this.InvokeAsync(StateHasChanged);
                }
            }
            else
            {
                break;
            }
        }
    }


    public void OnMouseMove(MouseEventArgs e)
    {
        if (!App.IsAutonomousMode)
        {
            meshSyncDemo?.AdjustPoint((float)e.ClientX, (float)e.ClientY);
            meshSyncDemo?.BroadCastMeshNodeStateChange(
                new vD2DNodeState(networkOverlay.NodeID, meshSyncDemo.CurrentXPos, meshSyncDemo.CurrentYPos, meshSyncDemo.Radius, App.CurrentSpeed, meshSyncDemo.CurrentDirection));
        }
    }

#line default
#line hidden
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private IMeshNodeInfo meshNodeInfo { get; set; }
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private ITime timeManager { get; set; }
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private IApp App { get; set; }
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private ILogicalP2PDemo p2pDemo { get; set; }
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private IMeshSyncDemo meshSyncDemo { get; set; }
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private INetworkOverlay networkOverlay { get; set; }
    }
}
#pragma warning restore 1591
